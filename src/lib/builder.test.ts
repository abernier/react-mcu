import { readFileSync } from "node:fs";
import { join } from "node:path";

import Ajv from "ajv";
import addFormats from "ajv-formats";
import { describe, expect, it } from "vitest";
import fixture from "../fixtures/material-theme-builder/try-01.json";
import fixture2 from "../fixtures/material-theme-builder/try-02.json";
import fixture3 from "../fixtures/material-theme-builder/try-03.json";
import fixture4 from "../fixtures/material-theme-builder/try-04.json";
import fixture5 from "../fixtures/material-theme-builder/try-05.json";
import darkThemeFixture from "../fixtures/theme/Dark.tokens.json";
import lightThemeFixture from "../fixtures/theme/Light.tokens.json";
import { builder, STANDARD_TONES } from "./builder";

// Strip `description` from fixture (present in native Material Theme Builder exports but not generated by builder())
const stripDescription = ({ description, ...rest }: Record<string, unknown>) =>
  rest;

describe("builder", () => {
  it("should match material theme builder fixture 1", () => {
    const result = builder("#769CDF").toJson();
    expect(result).toEqual(stripDescription(fixture));
  });

  it("should match material theme builder fixture 2", () => {
    const result = builder("#CAB337", {
      primary: "#CAB337",
      secondary: "#B03A3A",
      tertiary: "#2138D2",
      error: "#479200",
      neutral: "#957FF1",
      neutralVariant: "#007EDF",
      customColors: [
        { name: "Custom Color 1", hex: "#00D68A", blend: true },
        { name: "Custom Color 2", hex: "#FFE16B", blend: true },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture2));
  });

  it("should match material theme builder fixture 3", () => {
    const result = builder("#B33B15", {
      primary: "#B33B15",
      tertiary: "#009EBE",
      neutralVariant: "#C2C200",
      customColors: [
        { name: "Custom Color 1", hex: "#A4D386", blend: false },
        { name: "Custom Color 2", hex: "#FD0FB6", blend: false },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture3));
  });

  it("should match material theme builder fixture 4", () => {
    const result = builder("#63A002", {
      primary: "#63A002",
      error: "#FE00FC",
      neutral: "#75003C",
      customColors: [{ name: "Custom Color 1", hex: "#FFD646", blend: true }],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture4));
  });

  it("should match material theme builder fixture 5", () => {
    const result = builder("#F766FF", {
      primary: "#F766FF",
      tertiary: "#7BF600",
      error: "#311E00",
      neutralVariant: "#002726",
      customColors: [
        { name: "Custom Color 1", hex: "#F69C83", blend: true },
        { name: "Custom Color 2", hex: "#8DCCF8", blend: false },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture5));
  });

  it("should generate CSS with toCss()", () => {
    const result = builder("#769CDF").toCss();
    expect(result).toContain(":root {");
    expect(result).toContain(".dark {");
    expect(result).toContain(
      "--md-sys-color-primary:var(--md-ref-palette-primary-",
    );
  });

  describe("toFigmaTokens()", () => {
    // DTCG schemas are downloaded by scripts/download-dtcg-schemas.sh (via pretest hook)
    function loadSchema(relativePath: string) {
      const schemasDir = join(import.meta.dirname, "../fixtures/.dtcg-schemas");
      return JSON.parse(readFileSync(join(schemasDir, relativePath), "utf-8"));
    }

    function createDtcgValidator() {
      const ajv = new Ajv({ strict: false, allErrors: true });
      addFormats(ajv);

      // Register all sub-schemas (leaves before roots)
      ajv.addSchema(loadSchema("format/tokenType.json"));
      ajv.addSchema(loadSchema("format/values/color.json"));
      ajv.addSchema(loadSchema("format/values/dimension.json"));
      ajv.addSchema(loadSchema("format/values/fontFamily.json"));
      ajv.addSchema(loadSchema("format/values/fontWeight.json"));
      ajv.addSchema(loadSchema("format/values/duration.json"));
      ajv.addSchema(loadSchema("format/values/cubicBezier.json"));
      ajv.addSchema(loadSchema("format/values/number.json"));
      ajv.addSchema(loadSchema("format/values/strokeStyle.json"));
      ajv.addSchema(loadSchema("format/values/border.json"));
      ajv.addSchema(loadSchema("format/values/transition.json"));
      ajv.addSchema(loadSchema("format/values/shadow.json"));
      ajv.addSchema(loadSchema("format/values/gradient.json"));
      ajv.addSchema(loadSchema("format/values/typography.json"));
      ajv.addSchema(loadSchema("format/token.json"));
      ajv.addSchema(loadSchema("format/groupOrToken.json"));
      ajv.addSchema(loadSchema("format/group.json"));

      return ajv.compile(loadSchema("format.json"));
    }

    it("should produce valid DTCG tokens for each mode file", () => {
      const validate = createDtcgValidator();
      const files = builder("#6750A4").toFigmaTokens();

      for (const [filename, content] of Object.entries(files)) {
        const valid = validate(content);
        if (!valid) {
          console.error(
            `DTCG validation errors in ${filename}:`,
            validate.errors,
          );
        }
        expect(valid, `${filename} should be valid DTCG`).toBe(true);
      }
    });

    it("should match CLI-generated #6750A4 fixtures", () => {
      const result = builder("#6750A4").toFigmaTokens();

      expect(result["Light.tokens.json"]).toEqual(lightThemeFixture);
      expect(result["Dark.tokens.json"]).toEqual(darkThemeFixture);
    });

    it("should produce valid DTCG tokens with custom colors", () => {
      const validate = createDtcgValidator();
      const files = builder("#6750A4", {
        customColors: [
          { name: "brand", hex: "#FF5733", blend: true },
          { name: "success", hex: "#28A745", blend: false },
        ],
      }).toFigmaTokens();

      for (const [filename, content] of Object.entries(files)) {
        const valid = validate(content);
        if (!valid) {
          console.error(
            `DTCG validation errors in ${filename}:`,
            validate.errors,
          );
        }
        expect(valid, `${filename} should be valid DTCG`).toBe(true);
      }
    });

    it("should return Light.tokens.json and Dark.tokens.json files", () => {
      const result = builder("#6750A4").toFigmaTokens();

      expect(result).toHaveProperty("Light.tokens.json");
      expect(result).toHaveProperty("Dark.tokens.json");
      expect(Object.keys(result)).toHaveLength(2);
    });

    it("should contain ref.palette and sys.color groups in each mode file", () => {
      const result = builder("#6750A4").toFigmaTokens();

      for (const key of ["Light.tokens.json", "Dark.tokens.json"] as const) {
        const file = result[key];
        expect(file).toHaveProperty("ref");
        expect(file.ref).toHaveProperty("palette");
        expect(file).toHaveProperty("sys");
        expect(file.sys).toHaveProperty("color");
      }
    });

    it("should use Title Case names for scheme tokens", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const sysColor = result["Light.tokens.json"].sys.color;

      expect(sysColor).toHaveProperty("Primary");
      expect(sysColor).toHaveProperty("On Primary");
      expect(sysColor).toHaveProperty("Surface Container High");
    });

    it("should use Title Case names for palette groups", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const refPalette = result["Light.tokens.json"].ref.palette;

      expect(refPalette).toHaveProperty("Primary");
      expect(refPalette).toHaveProperty("Secondary");
      expect(refPalette).toHaveProperty("Tertiary");
      expect(refPalette).toHaveProperty("Error");
      expect(refPalette).toHaveProperty("Neutral");
      expect(refPalette).toHaveProperty("Neutral Variant");
    });

    it("should include all standard tones in each palette", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const primaryPalette = result["Light.tokens.json"].ref.palette[
        "Primary"
      ] as Record<string, unknown>;

      for (const tone of STANDARD_TONES) {
        expect(primaryPalette).toHaveProperty(tone.toString());
      }
    });

    it("should produce Figma-compatible ref palette tokens with color objects", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const tone40 = (
        result["Light.tokens.json"].ref.palette as Record<
          string,
          Record<string, unknown>
        >
      )["Primary"]!["40"]! as {
        $type: string;
        $value: {
          colorSpace: string;
          components: number[];
          alpha: number;
          hex: string;
        };
        $extensions: Record<string, unknown>;
      };

      expect(tone40.$type).toBe("color");
      expect(tone40.$value.colorSpace).toBe("srgb");
      expect(tone40.$value.components).toHaveLength(3);
      expect(tone40.$value.components.every((c) => c >= 0 && c <= 1)).toBe(
        true,
      );
      expect(tone40.$value.alpha).toBe(1);
      expect(tone40.$value.hex).toMatch(/^#[0-9A-F]{6}$/);
      expect(tone40.$extensions["com.figma.scopes"]).toEqual(["ALL_SCOPES"]);
    });

    it("should produce sys tokens with alias references in each mode file", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const lightPrimary = (
        result["Light.tokens.json"].sys.color as Record<string, unknown>
      )["Primary"] as {
        $type: string;
        $value: string;
        $description: string;
        $extensions: Record<string, unknown>;
      };
      const darkPrimary = (
        result["Dark.tokens.json"].sys.color as Record<string, unknown>
      )["Primary"] as {
        $type: string;
        $value: string;
        $extensions: Record<string, unknown>;
      };

      expect(lightPrimary.$type).toBe("color");
      expect(lightPrimary.$value).toMatch(/^\{ref\.palette\..+\}$/);
      expect(lightPrimary.$description).toBeDefined();
      expect(lightPrimary.$extensions["com.figma.scopes"]).toEqual([
        "ALL_SCOPES",
      ]);
      expect(lightPrimary.$extensions["css.variable"]).toBe(
        "--md-sys-color-primary",
      );

      expect(darkPrimary.$type).toBe("color");
      expect(darkPrimary.$value).toMatch(/^\{ref\.palette\..+\}$/);

      // Light and Dark should reference different tones
      expect(lightPrimary.$value).not.toBe(darkPrimary.$value);
    });

    it("should have different aliases for scheme tokens across modes", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const lightPrimary = (
        result["Light.tokens.json"].sys.color as Record<string, unknown>
      )["Primary"] as {
        $value: string;
      };
      const darkPrimary = (
        result["Dark.tokens.json"].sys.color as Record<string, unknown>
      )["Primary"] as {
        $value: string;
      };

      // Primary is tone 40 in Light, tone 80 in Dark
      expect(lightPrimary.$value).not.toBe(darkPrimary.$value);
    });

    it("should produce mode-independent ref palette tones", () => {
      // ref palette is always the same in both mode files
      // (adaptiveShades only affects CSS output, not Figma tokens)
      const result = builder("#6750A4", {
        adaptiveShades: true,
      }).toFigmaTokens();
      const resultNoAdaptive = builder("#6750A4", {
        adaptiveShades: false,
      }).toFigmaTokens();

      const palette = (
        result["Light.tokens.json"].ref.palette as Record<
          string,
          Record<string, { $value: { hex: string } }>
        >
      )["Primary"]!;
      const paletteNoAdaptive = (
        resultNoAdaptive["Light.tokens.json"].ref.palette as Record<
          string,
          Record<string, { $value: { hex: string } }>
        >
      )["Primary"]!;

      // Palette tones should be identical regardless of adaptiveShades
      expect(palette["40"]!.$value.hex).toBe(
        paletteNoAdaptive["40"]!.$value.hex,
      );

      // Both mode files should share the same ref palette
      const lightPalette = result["Light.tokens.json"].ref.palette;
      const darkPalette = result["Dark.tokens.json"].ref.palette;
      expect(lightPalette).toEqual(darkPalette);
    });

    it("should include custom color palettes and scheme tokens", () => {
      const result = builder("#6750A4", {
        customColors: [{ name: "brand", hex: "#FF5733", blend: true }],
      }).toFigmaTokens();

      for (const key of ["Light.tokens.json", "Dark.tokens.json"] as const) {
        const file = result[key];

        // Custom color should appear in ref palette
        expect(file.ref.palette).toHaveProperty("Brand");

        // Custom color scheme tokens in sys.color
        expect(file.sys.color).toHaveProperty("Brand");
        expect(file.sys.color).toHaveProperty("On Brand");
        expect(file.sys.color).toHaveProperty("Brand Container");
        expect(file.sys.color).toHaveProperty("On Brand Container");
      }
    });

    it("should contain com.figma.modeName in each mode file", () => {
      const result = builder("#6750A4").toFigmaTokens();

      const lightExt = result["Light.tokens.json"].$extensions as Record<
        string,
        unknown
      >;
      const darkExt = result["Dark.tokens.json"].$extensions as Record<
        string,
        unknown
      >;
      expect(lightExt["com.figma.modeName"]).toBe("Light");
      expect(darkExt["com.figma.modeName"]).toBe("Dark");
    });
  });
});
