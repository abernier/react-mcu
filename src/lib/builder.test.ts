import { readFileSync } from "node:fs";
import { join } from "node:path";

import Ajv from "ajv";
import addFormats from "ajv-formats";
import { describe, expect, it } from "vitest";
import fixture from "../fixtures/material-theme-builder/try-01.json";
import fixture2 from "../fixtures/material-theme-builder/try-02.json";
import fixture3 from "../fixtures/material-theme-builder/try-03.json";
import fixture4 from "../fixtures/material-theme-builder/try-04.json";
import fixture5 from "../fixtures/material-theme-builder/try-05.json";
import darkThemeFixture from "../fixtures/theme/Dark.tokens.json";
import lightThemeFixture from "../fixtures/theme/Light.tokens.json";
import { builder, STANDARD_TONES } from "./builder";

// Strip `description` from fixture (present in native Material Theme Builder exports but not generated by builder())
const stripDescription = ({ description, ...rest }: Record<string, unknown>) =>
  rest;

describe("builder", () => {
  it("should match material theme builder fixture 1", () => {
    const result = builder("#769CDF").toJson();
    expect(result).toEqual(stripDescription(fixture));
  });

  it("should match material theme builder fixture 2", () => {
    const result = builder("#CAB337", {
      primary: "#CAB337",
      secondary: "#B03A3A",
      tertiary: "#2138D2",
      error: "#479200",
      neutral: "#957FF1",
      neutralVariant: "#007EDF",
      customColors: [
        { name: "Custom Color 1", hex: "#00D68A", blend: true },
        { name: "Custom Color 2", hex: "#FFE16B", blend: true },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture2));
  });

  it("should match material theme builder fixture 3", () => {
    const result = builder("#B33B15", {
      primary: "#B33B15",
      tertiary: "#009EBE",
      neutralVariant: "#C2C200",
      customColors: [
        { name: "Custom Color 1", hex: "#A4D386", blend: false },
        { name: "Custom Color 2", hex: "#FD0FB6", blend: false },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture3));
  });

  it("should match material theme builder fixture 4", () => {
    const result = builder("#63A002", {
      primary: "#63A002",
      error: "#FE00FC",
      neutral: "#75003C",
      customColors: [{ name: "Custom Color 1", hex: "#FFD646", blend: true }],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture4));
  });

  it("should match material theme builder fixture 5", () => {
    const result = builder("#F766FF", {
      primary: "#F766FF",
      tertiary: "#7BF600",
      error: "#311E00",
      neutralVariant: "#002726",
      customColors: [
        { name: "Custom Color 1", hex: "#F69C83", blend: true },
        { name: "Custom Color 2", hex: "#8DCCF8", blend: false },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture5));
  });

  it("should generate CSS with toCss()", () => {
    const result = builder("#769CDF").toCss();
    expect(result).toContain(":root {");
    expect(result).toContain(".dark {");
    expect(result).toContain("--mcu-primary");
  });

  describe("toFigmaTokens()", () => {
    // DTCG schemas are downloaded by scripts/download-dtcg-schemas.sh (via pretest hook)
    function loadSchema(relativePath: string) {
      const schemasDir = join(import.meta.dirname, "../fixtures/.dtcg-schemas");
      return JSON.parse(readFileSync(join(schemasDir, relativePath), "utf-8"));
    }

    function createDtcgValidator() {
      const ajv = new Ajv({ strict: false, allErrors: true });
      addFormats(ajv);

      // Register all sub-schemas (leaves before roots)
      ajv.addSchema(loadSchema("format/tokenType.json"));
      ajv.addSchema(loadSchema("format/values/color.json"));
      ajv.addSchema(loadSchema("format/values/dimension.json"));
      ajv.addSchema(loadSchema("format/values/fontFamily.json"));
      ajv.addSchema(loadSchema("format/values/fontWeight.json"));
      ajv.addSchema(loadSchema("format/values/duration.json"));
      ajv.addSchema(loadSchema("format/values/cubicBezier.json"));
      ajv.addSchema(loadSchema("format/values/number.json"));
      ajv.addSchema(loadSchema("format/values/strokeStyle.json"));
      ajv.addSchema(loadSchema("format/values/border.json"));
      ajv.addSchema(loadSchema("format/values/transition.json"));
      ajv.addSchema(loadSchema("format/values/shadow.json"));
      ajv.addSchema(loadSchema("format/values/gradient.json"));
      ajv.addSchema(loadSchema("format/values/typography.json"));
      ajv.addSchema(loadSchema("format/token.json"));
      ajv.addSchema(loadSchema("format/groupOrToken.json"));
      ajv.addSchema(loadSchema("format/group.json"));

      return ajv.compile(loadSchema("format.json"));
    }

    it("should produce valid DTCG tokens for each mode file", () => {
      const validate = createDtcgValidator();
      const files = builder("#6750A4").toFigmaTokens();

      for (const [filename, content] of Object.entries(files)) {
        const valid = validate(content);
        if (!valid) {
          console.error(
            `DTCG validation errors in ${filename}:`,
            validate.errors,
          );
        }
        expect(valid, `${filename} should be valid DTCG`).toBe(true);
      }
    });

    it("should match CLI-generated #6750A4 fixtures", () => {
      const result = builder("#6750A4").toFigmaTokens();

      expect(result["Light.tokens.json"]).toEqual(lightThemeFixture);
      expect(result["Dark.tokens.json"]).toEqual(darkThemeFixture);
    });

    it("should produce valid DTCG tokens with custom colors", () => {
      const validate = createDtcgValidator();
      const files = builder("#6750A4", {
        customColors: [
          { name: "brand", hex: "#FF5733", blend: true },
          { name: "success", hex: "#28A745", blend: false },
        ],
      }).toFigmaTokens();

      for (const [filename, content] of Object.entries(files)) {
        const valid = validate(content);
        if (!valid) {
          console.error(
            `DTCG validation errors in ${filename}:`,
            validate.errors,
          );
        }
        expect(valid, `${filename} should be valid DTCG`).toBe(true);
      }
    });

    it("should return Light.tokens.json and Dark.tokens.json files", () => {
      const result = builder("#6750A4").toFigmaTokens();

      expect(result).toHaveProperty("Light.tokens.json");
      expect(result).toHaveProperty("Dark.tokens.json");
      expect(Object.keys(result)).toHaveLength(2);
    });

    it("should include com.figma.modeName extension on each file", () => {
      const result = builder("#6750A4").toFigmaTokens();

      expect(
        result["Light.tokens.json"].$extensions["com.figma.modeName"],
      ).toBe("Light");
      expect(result["Dark.tokens.json"].$extensions["com.figma.modeName"]).toBe(
        "Dark",
      );
    });

    it("should contain Schemes and Palettes groups in each mode", () => {
      const result = builder("#6750A4").toFigmaTokens();

      for (const file of Object.values(result)) {
        expect(file).toHaveProperty("Schemes");
        expect(file).toHaveProperty("Palettes");
      }
    });

    it("should use Title Case names for scheme tokens", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const lightSchemes = result["Light.tokens.json"].Schemes;

      expect(lightSchemes).toHaveProperty("Primary");
      expect(lightSchemes).toHaveProperty("On Primary");
      expect(lightSchemes).toHaveProperty("Surface Container High");
    });

    it("should use Title Case names for palette groups", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const lightPalettes = result["Light.tokens.json"].Palettes;

      expect(lightPalettes).toHaveProperty("Primary");
      expect(lightPalettes).toHaveProperty("Secondary");
      expect(lightPalettes).toHaveProperty("Tertiary");
      expect(lightPalettes).toHaveProperty("Error");
      expect(lightPalettes).toHaveProperty("Neutral");
      expect(lightPalettes).toHaveProperty("Neutral Variant");
    });

    it("should include all standard tones in each palette", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const primaryPalette = result["Light.tokens.json"].Palettes
        .Primary as Record<string, unknown>;

      for (const tone of STANDARD_TONES) {
        expect(primaryPalette).toHaveProperty(tone.toString());
      }
    });

    it("should produce Figma-compatible color tokens with scopes and alpha", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const primaryToken = result["Light.tokens.json"].Schemes.Primary as {
        $type: string;
        $value: {
          colorSpace: string;
          components: number[];
          alpha: number;
          hex: string;
        };
        $extensions: Record<string, unknown>;
      };

      expect(primaryToken.$type).toBe("color");
      expect(primaryToken.$value.colorSpace).toBe("srgb");
      expect(primaryToken.$value.components).toHaveLength(3);
      expect(
        primaryToken.$value.components.every((c) => c >= 0 && c <= 1),
      ).toBe(true);
      expect(primaryToken.$value.alpha).toBe(1);
      expect(primaryToken.$value.hex).toMatch(/^#[0-9A-F]{6}$/);
      expect(primaryToken.$extensions["com.figma.scopes"]).toEqual([
        "ALL_SCOPES",
      ]);
      expect(primaryToken.$extensions["com.figma.isOverride"]).toBe(true);
    });

    it("should have different scheme values between Light and Dark", () => {
      const result = builder("#6750A4").toFigmaTokens();

      const lightPrimary = result["Light.tokens.json"].Schemes.Primary as {
        $value: { hex: string };
      };
      const darkPrimary = result["Dark.tokens.json"].Schemes.Primary as {
        $value: { hex: string };
      };

      expect(lightPrimary.$value.hex).not.toBe(darkPrimary.$value.hex);
    });

    it("should produce different palette tones for dark mode when adaptiveShades is enabled", () => {
      const result = builder("#6750A4", {
        adaptiveShades: true,
      }).toFigmaTokens();

      const lightTone40 = result["Light.tokens.json"].Palettes.Primary![
        "40"
      ] as {
        $value: { hex: string };
      };
      const darkTone40 = result["Dark.tokens.json"].Palettes.Primary!["40"] as {
        $value: { hex: string };
      };

      // With adaptiveShades, dark tone 40 should map to tone 60 (100 - 40)
      expect(lightTone40.$value.hex).not.toBe(darkTone40.$value.hex);
    });

    it("should produce identical palette tones for dark/light when adaptiveShades is disabled", () => {
      const result = builder("#6750A4", {
        adaptiveShades: false,
      }).toFigmaTokens();

      const lightTone40 = result["Light.tokens.json"].Palettes.Primary![
        "40"
      ] as {
        $value: { hex: string };
      };
      const darkTone40 = result["Dark.tokens.json"].Palettes.Primary!["40"] as {
        $value: { hex: string };
      };

      expect(lightTone40.$value.hex).toBe(darkTone40.$value.hex);
    });

    it("should include custom color palettes and scheme tokens", () => {
      const result = builder("#6750A4", {
        customColors: [{ name: "brand", hex: "#FF5733", blend: true }],
      }).toFigmaTokens();

      // Custom color should appear in palettes
      expect(result["Light.tokens.json"].Palettes).toHaveProperty("Brand");
      expect(result["Dark.tokens.json"].Palettes).toHaveProperty("Brand");

      // Custom color scheme tokens
      expect(result["Light.tokens.json"].Schemes).toHaveProperty("Brand");
      expect(result["Light.tokens.json"].Schemes).toHaveProperty("On Brand");
      expect(result["Light.tokens.json"].Schemes).toHaveProperty(
        "Brand Container",
      );
      expect(result["Light.tokens.json"].Schemes).toHaveProperty(
        "On Brand Container",
      );

      expect(result["Dark.tokens.json"].Schemes).toHaveProperty("Brand");
      expect(result["Dark.tokens.json"].Schemes).toHaveProperty("On Brand");
      expect(result["Dark.tokens.json"].Schemes).toHaveProperty(
        "Brand Container",
      );
      expect(result["Dark.tokens.json"].Schemes).toHaveProperty(
        "On Brand Container",
      );
    });
  });
});
