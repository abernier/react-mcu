import { readFileSync } from "node:fs";
import { join } from "node:path";

import Ajv from "ajv";
import addFormats from "ajv-formats";
import { describe, expect, it } from "vitest";
import fixture from "../fixtures/material-theme-builder/try-01.json";
import fixture2 from "../fixtures/material-theme-builder/try-02.json";
import fixture3 from "../fixtures/material-theme-builder/try-03.json";
import fixture4 from "../fixtures/material-theme-builder/try-04.json";
import fixture5 from "../fixtures/material-theme-builder/try-05.json";
import themeFixture from "../fixtures/theme/theme.tokens.json";
import { builder, STANDARD_TONES } from "./builder";

// Strip `description` from fixture (present in native Material Theme Builder exports but not generated by builder())
const stripDescription = ({ description, ...rest }: Record<string, unknown>) =>
  rest;

describe("builder", () => {
  it("should match material theme builder fixture 1", () => {
    const result = builder("#769CDF").toJson();
    expect(result).toEqual(stripDescription(fixture));
  });

  it("should match material theme builder fixture 2", () => {
    const result = builder("#CAB337", {
      primary: "#CAB337",
      secondary: "#B03A3A",
      tertiary: "#2138D2",
      error: "#479200",
      neutral: "#957FF1",
      neutralVariant: "#007EDF",
      customColors: [
        { name: "Custom Color 1", hex: "#00D68A", blend: true },
        { name: "Custom Color 2", hex: "#FFE16B", blend: true },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture2));
  });

  it("should match material theme builder fixture 3", () => {
    const result = builder("#B33B15", {
      primary: "#B33B15",
      tertiary: "#009EBE",
      neutralVariant: "#C2C200",
      customColors: [
        { name: "Custom Color 1", hex: "#A4D386", blend: false },
        { name: "Custom Color 2", hex: "#FD0FB6", blend: false },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture3));
  });

  it("should match material theme builder fixture 4", () => {
    const result = builder("#63A002", {
      primary: "#63A002",
      error: "#FE00FC",
      neutral: "#75003C",
      customColors: [{ name: "Custom Color 1", hex: "#FFD646", blend: true }],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture4));
  });

  it("should match material theme builder fixture 5", () => {
    const result = builder("#F766FF", {
      primary: "#F766FF",
      tertiary: "#7BF600",
      error: "#311E00",
      neutralVariant: "#002726",
      customColors: [
        { name: "Custom Color 1", hex: "#F69C83", blend: true },
        { name: "Custom Color 2", hex: "#8DCCF8", blend: false },
      ],
    }).toJson();
    expect(result).toEqual(stripDescription(fixture5));
  });

  it("should generate CSS with toCss()", () => {
    const result = builder("#769CDF").toCss();
    expect(result).toContain(":root {");
    expect(result).toContain(".dark {");
    expect(result).toContain("--mcu-primary");
  });

  describe("toFigmaTokens()", () => {
    // DTCG schemas are downloaded by scripts/download-dtcg-schemas.sh (via pretest hook)
    function loadSchema(relativePath: string) {
      const schemasDir = join(import.meta.dirname, "../fixtures/.dtcg-schemas");
      return JSON.parse(readFileSync(join(schemasDir, relativePath), "utf-8"));
    }

    function createDtcgValidator() {
      const ajv = new Ajv({ strict: false, allErrors: true });
      addFormats(ajv);

      // Register all sub-schemas (leaves before roots)
      ajv.addSchema(loadSchema("format/tokenType.json"));
      ajv.addSchema(loadSchema("format/values/color.json"));
      ajv.addSchema(loadSchema("format/values/dimension.json"));
      ajv.addSchema(loadSchema("format/values/fontFamily.json"));
      ajv.addSchema(loadSchema("format/values/fontWeight.json"));
      ajv.addSchema(loadSchema("format/values/duration.json"));
      ajv.addSchema(loadSchema("format/values/cubicBezier.json"));
      ajv.addSchema(loadSchema("format/values/number.json"));
      ajv.addSchema(loadSchema("format/values/strokeStyle.json"));
      ajv.addSchema(loadSchema("format/values/border.json"));
      ajv.addSchema(loadSchema("format/values/transition.json"));
      ajv.addSchema(loadSchema("format/values/shadow.json"));
      ajv.addSchema(loadSchema("format/values/gradient.json"));
      ajv.addSchema(loadSchema("format/values/typography.json"));
      ajv.addSchema(loadSchema("format/token.json"));
      ajv.addSchema(loadSchema("format/groupOrToken.json"));
      ajv.addSchema(loadSchema("format/group.json"));

      return ajv.compile(loadSchema("format.json"));
    }

    it("should produce valid DTCG tokens for each mode file", () => {
      const validate = createDtcgValidator();
      const files = builder("#6750A4").toFigmaTokens();

      for (const [filename, content] of Object.entries(files)) {
        const valid = validate(content);
        if (!valid) {
          console.error(
            `DTCG validation errors in ${filename}:`,
            validate.errors,
          );
        }
        expect(valid, `${filename} should be valid DTCG`).toBe(true);
      }
    });

    it("should match CLI-generated #6750A4 fixtures", () => {
      const result = builder("#6750A4").toFigmaTokens();

      expect(result["theme.tokens.json"]).toEqual(themeFixture);
    });

    it("should produce valid DTCG tokens with custom colors", () => {
      const validate = createDtcgValidator();
      const files = builder("#6750A4", {
        customColors: [
          { name: "brand", hex: "#FF5733", blend: true },
          { name: "success", hex: "#28A745", blend: false },
        ],
      }).toFigmaTokens();

      for (const [filename, content] of Object.entries(files)) {
        const valid = validate(content);
        if (!valid) {
          console.error(
            `DTCG validation errors in ${filename}:`,
            validate.errors,
          );
        }
        expect(valid, `${filename} should be valid DTCG`).toBe(true);
      }
    });

    it("should return a single theme.tokens.json file", () => {
      const result = builder("#6750A4").toFigmaTokens();

      expect(result).toHaveProperty("theme.tokens.json");
      expect(Object.keys(result)).toHaveLength(1);
    });

    it("should contain ref.palette and sys.color groups", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const file = result["theme.tokens.json"];

      expect(file).toHaveProperty("ref");
      expect(file.ref).toHaveProperty("palette");
      expect(file).toHaveProperty("sys");
      expect(file.sys).toHaveProperty("color");
    });

    it("should use kebab-case names for scheme tokens", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const sysColor = result["theme.tokens.json"].sys.color;

      expect(sysColor).toHaveProperty("primary");
      expect(sysColor).toHaveProperty("on-primary");
      expect(sysColor).toHaveProperty("surface-container-high");
    });

    it("should use kebab-case names for palette groups", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const refPalette = result["theme.tokens.json"].ref.palette;

      expect(refPalette).toHaveProperty("primary");
      expect(refPalette).toHaveProperty("secondary");
      expect(refPalette).toHaveProperty("tertiary");
      expect(refPalette).toHaveProperty("error");
      expect(refPalette).toHaveProperty("neutral");
      expect(refPalette).toHaveProperty("neutral-variant");
    });

    it("should include all standard tones in each palette", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const primaryPalette = result["theme.tokens.json"].ref.palette
        .primary as Record<string, unknown>;

      for (const tone of STANDARD_TONES) {
        expect(primaryPalette).toHaveProperty(tone.toString());
      }
    });

    it("should produce Figma-compatible ref palette tokens with color objects", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const tone40 = result["theme.tokens.json"].ref.palette.primary[
        "40"
      ] as {
        $type: string;
        $value: {
          colorSpace: string;
          components: number[];
          alpha: number;
          hex: string;
        };
        $extensions: Record<string, unknown>;
      };

      expect(tone40.$type).toBe("color");
      expect(tone40.$value.colorSpace).toBe("srgb");
      expect(tone40.$value.components).toHaveLength(3);
      expect(
        tone40.$value.components.every((c) => c >= 0 && c <= 1),
      ).toBe(true);
      expect(tone40.$value.alpha).toBe(1);
      expect(tone40.$value.hex).toMatch(/^#[0-9A-F]{6}$/);
      expect(tone40.$extensions["com.figma.scopes"]).toEqual(["ALL_SCOPES"]);
    });

    it("should produce sys tokens with com.figma.modes for Light and Dark", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const primary = result["theme.tokens.json"].sys.color.primary as {
        $type: string;
        $value: string;
        $description: string;
        $extensions: Record<string, unknown>;
      };

      expect(primary.$type).toBe("color");
      // $value is a DTCG alias reference (Light mode default)
      expect(primary.$value).toMatch(/^\{ref\.palette\..+\}$/);
      expect(primary.$description).toBeDefined();
      expect(primary.$extensions["com.figma.scopes"]).toEqual(["ALL_SCOPES"]);
      expect(primary.$extensions["css.variable"]).toBe(
        "--md-sys-color-primary",
      );

      // com.figma.modes provides Light and Dark aliases
      const modes = primary.$extensions["com.figma.modes"] as Record<
        string,
        string
      >;
      expect(modes).toHaveProperty("Light");
      expect(modes).toHaveProperty("Dark");
      expect(modes.Light).toMatch(/^\{ref\.palette\..+\}$/);
      expect(modes.Dark).toMatch(/^\{ref\.palette\..+\}$/);
      // Light and Dark should reference different tones
      expect(modes.Light).not.toBe(modes.Dark);
    });

    it("should have different Light and Dark mode aliases for scheme tokens", () => {
      const result = builder("#6750A4").toFigmaTokens();
      const primary = result["theme.tokens.json"].sys.color.primary as {
        $extensions: { "com.figma.modes": Record<string, string> };
      };

      // Primary is tone 40 in Light, tone 80 in Dark
      expect(primary.$extensions["com.figma.modes"].Light).not.toBe(
        primary.$extensions["com.figma.modes"].Dark,
      );
    });

    it("should produce mode-independent ref palette tones", () => {
      // In the single-file format, ref palette is always the same
      // (adaptiveShades only affects CSS output, not Figma tokens)
      const result = builder("#6750A4", {
        adaptiveShades: true,
      }).toFigmaTokens();
      const resultNoAdaptive = builder("#6750A4", {
        adaptiveShades: false,
      }).toFigmaTokens();

      const palette = result["theme.tokens.json"].ref.palette.primary as Record<
        string,
        { $value: { hex: string } }
      >;
      const paletteNoAdaptive = resultNoAdaptive["theme.tokens.json"].ref
        .palette.primary as Record<string, { $value: { hex: string } }>;

      // Palette tones should be identical regardless of adaptiveShades
      expect(palette["40"].$value.hex).toBe(paletteNoAdaptive["40"].$value.hex);
    });

    it("should include custom color palettes and scheme tokens", () => {
      const result = builder("#6750A4", {
        customColors: [{ name: "brand", hex: "#FF5733", blend: true }],
      }).toFigmaTokens();
      const file = result["theme.tokens.json"];

      // Custom color should appear in ref palette
      expect(file.ref.palette).toHaveProperty("brand");

      // Custom color scheme tokens in sys.color
      expect(file.sys.color).toHaveProperty("brand");
      expect(file.sys.color).toHaveProperty("on-brand");
      expect(file.sys.color).toHaveProperty("brand-container");
      expect(file.sys.color).toHaveProperty("on-brand-container");

      // Custom color sys tokens should have com.figma.modes
      const brandToken = file.sys.color.brand as {
        $extensions: Record<string, unknown>;
      };
      expect(brandToken.$extensions["com.figma.modes"]).toHaveProperty("Light");
      expect(brandToken.$extensions["com.figma.modes"]).toHaveProperty("Dark");
    });
  });
});
